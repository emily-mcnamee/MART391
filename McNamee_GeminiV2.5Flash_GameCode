let player;
let collectibles = [];
let enemies = [];
let collectedCount = 0;
let gameState = 'playing';
let winZone;

function setup() {
  createCanvas(600, 600);
  player = new Player();
  winZone = createVector(width / 2, height / 2);
  
  // Spawn collectibles
  for (let i = 0; i < 3; i++) {
    collectibles.push(new Collectible());
  }
  
  // Spawn enemies
  for (let i = 0; i < 5; i++) {
    enemies.push(new Enemy());
  }
}

function draw() {
  background(220);
  
  if (gameState === 'playing') {
    player.update();
    player.show();
    
    // Draw win zone
    fill(0, 255, 0, 50);
    noStroke();
    ellipse(winZone.x, winZone.y, 100, 100);
    
    // Handle collectibles
    for (let i = collectibles.length - 1; i >= 0; i--) {
      collectibles[i].show();
      if (player.collidesWith(collectibles[i])) {
        collectibles.splice(i, 1);
        collectedCount++;
      }
    }
    
    // Handle enemies
    for (let i = 0; i < enemies.length; i++) {
      enemies[i].update();
      enemies[i].show();
      if (player.collidesWith(enemies[i])) {
        gameState = 'lost';
      }
    }
    
    // Check for win condition
    if (collectedCount === 3 && dist(player.pos.x, player.pos.y, winZone.x, winZone.y) < 50) {
      gameState = 'won';
    }
    
    // Display score
    textSize(24);
    fill(0);
    text('Objects Collected: ' + collectedCount + '/3', 10, 30);
    
  } else if (gameState === 'won') {
    displayMessage('YOU WON!');
  } else if (gameState === 'lost') {
    displayMessage('GAME OVER');
  }
}

function displayMessage(msg) {
  textSize(50);
  textAlign(CENTER, CENTER);
  fill(0);
  text(msg, width / 2, height / 2);
}

class Player {
  constructor() {
    this.pos = createVector(width / 2, height / 2);
    this.size = 20;
    this.speed = 5;
  }
  
  update() {
    if (keyIsDown(LEFT_ARROW)) {
      this.pos.x -= this.speed;
    }
    if (keyIsDown(RIGHT_ARROW)) {
      this.pos.x += this.speed;
    }
    if (keyIsDown(UP_ARROW)) {
      this.pos.y -= this.speed;
    }
    if (keyIsDown(DOWN_ARROW)) {
      this.pos.y += this.speed;
    }
    
    // Keep player on screen
    this.pos.x = constrain(this.pos.x, 0, width);
    this.pos.y = constrain(this.pos.y, 0, height);
  }
  
  show() {
    fill(0, 0, 255);
    rectMode(CENTER);
    rect(this.pos.x, this.pos.y, this.size, this.size);
  }
  
  collidesWith(other) {
    let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);
    return d < (this.size / 2 + other.size / 2);
  }
}

class Collectible {
  constructor() {
    this.pos = createVector(random(width), random(height));
    this.size = 15;
  }
  
  show() {
    fill(255, 255, 0);
    ellipse(this.pos.x, this.pos.y, this.size, this.size);
  }
}

class Enemy {
  constructor() {
    this.pos = createVector(random(width), random(height));
    this.size = 30;
    this.velocity = p5.Vector.random2D().mult(random(1, 3));
  }
  
  update() {
    this.pos.add(this.velocity);
    
    // Bounce off walls
    if (this.pos.x < 0 || this.pos.x > width) {
      this.velocity.x *= -1;
    }
    if (this.pos.y < 0 || this.pos.y > height) {
      this.velocity.y *= -1;
    }
  }
  
  show() {
    fill(255, 0, 0);
    triangle(this.pos.x, this.pos.y - this.size / 2,
             this.pos.x - this.size / 2, this.pos.y + this.size / 2,
             this.pos.x + this.size / 2, this.pos.y + this.size / 2);
  }
}
